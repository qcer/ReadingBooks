### **基础篇**

1、ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。

2、ECMAScript 使用 C 风格的注释，包括单行注释和块级注释。单行注释以两个斜杠开头，如下所示：

	// 单行注释

块级注释以一个斜杠和一个星号（/*）开头，以一个星号和一个斜杠（*/）结尾，如下所示：

	/*
	* 这是一个多行
	* （块级）注释
	*/

3、严格模式
ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模型。在严格模式下， ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：

	"use strict";

这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为不破坏 ECMAScript 3 语法而特意选定的语法。

在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：

	function doSomething(){
		"use strict";
		//函数体
	}

4、变量的松散特性

ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用 var 操作符（注意 var 是一个关键字），后跟变量名（即一个标识符）。
例如:

	var message = "hi";
	message = 100; // 有效，但不推荐

5、不推荐省略var定义变量

虽然省略 var 操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局
部作用域中定义的全局变量很难维护，而且如果有意地忽略了 var 操作符，也会由于
相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式
下会导致抛出 ReferenceError 错误。

6、多个变量串行定义

	var message = "hi",
		found = false,
		age = 29;


7、
typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。

8、
对未初始化的变量执行 typeof 操作符会返回 undefined 值，而对未声明的变量执行 typeof 操作符同样也会返回 undefined 值。来看下面的例子：

	var message; // 这个变量声明之后默认取得了 undefined 值
	// 下面这个变量并没有声明
	// var age
	alert(typeof message); // "undefined"
	alert(typeof age); // "undefined"

9、
无论在什么情况下都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。

问：

var obj1 = null;

var obj2 = {}
两者有什么区别？？

10、不建议测试某个特定的浮点数

		var a = 0.1,
			b= 0.2;
		if (a + b == 0.3) {
			console.log('ok')
		}else{
			console.log(a+b) //0.30000000000000004
		}

11、 关于NaN

NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）
NaN 本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN，这个特点在多步计算中有可能导致问题。其次， NaN 与任何值都不相等，包括 NaN 本身。

	alert(isNaN(NaN)); //true
	alert(isNaN(10)); //false（ 10 是一个数值）
	alert(isNaN("10")); //false（可以被转换成数值 10）
	alert(isNaN("blue")); //true（不能转换成数值）
	alert(isNaN(true)); //false（可以被转换成数值 1）

12、数值转换

有 3 个函数可以把非数值转换为数值： Number()、 parseInt()和 parseFloat()。第一个函数，
即转型函数 Number()可以用于任何数据类型，

Number()函数的转换规则如下。
* 如果是 Boolean 值， true 和 false 将分别被转换为 1 和 0。
* 如果是数字值，只是简单的传入和返回。
* 如果是 null 值，返回 0。
* 如果是 undefined，返回 NaN。
* 如果是字符串，遵循下列规则：
* 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"会变成 1， "123"会变成 123，而"011"会变成 11（注意：前导的零被忽略了）；
* 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽
略前导零）；
* 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值；
* 如果字符串是空的（不包含任何字符），则将其转换为 0；
* 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。
* 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。

字符串中可能嵌入数字，如"123abc"这种形式，Number在将字符串转换成数值是不方便，因此parseInt()和 parseFloat()经常用于字符串转换成数值。

**如果第一个字符不是数字字符或者负号， parseInt()就会返回 NaN；**
例如:

		console.log(parseInt("abc123")); //NaN
		console.log(parseInt("123abc")); //123

13、
Object 的每个实例都具有下列属性和方法。
* constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object()。
* hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例
的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如： o.hasOwnProperty("name")）。
* isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原型） 。
* propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
* toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
* toString()：返回对象的字符串表示。
* valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。

14、
ECMAScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参
数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而
引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因
为访问变量有按值和按引用两种方式，而参数只能按值传递。

在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用
ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把
这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

15、
检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的
用处不大。 通常， 我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此， ECMAScript
提供了 instanceof 操作符，

16、解除引用（dereferencing）

一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做**解除引用（dereferencing）**。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用.

17、在使用对象字面量语法时，属性名也可以使用字符串，如下面这个例子所示。

	var person = {
		"name" : "Nicholas",
		"age" : 29,
		5 : true
	};

这个例子会创建一个对象，包含三个属性： name、 age 和 5。但这里的数值属性名会自动转换为字符串。